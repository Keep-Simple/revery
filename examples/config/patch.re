/* patch.re
   This patches Windows executables generated by dune
   with a custom manifest. This is particularly useful
   to tell the dynamic linker what version of a DLL to bring
   in, or to embed version information in the file.

   The benefit of using this file is that it's portable,
   as long as the host has a Windows SDK install. Unfortunately,
   Microsoft can't seem to decide on one place to store the SDK
   tools, so most of this file is trying to find where those are.
   */

type sdk =
  | Windows81(string)
  | Windows10(string, string);

/* Executes a command
   Returns the output to STDOUT as a list of strings (lines)
   */
let exec = cmd => {
  let ic = Unix.open_process_in(cmd);
  let rec toString = current => {
    let line =
      try(Some(input_line(ic))) {
      | End_of_file => None
      };
    switch (line) {
    | Some(str) => toString([str, ...current])
    | None => List.rev(current)
    };
  };
  toString([]);
};

/* Retry operator
   I actually don't know if this is a thing elsewhere,
   but I wanted an operator that basically said "If this value is None,
   try calling this function to try again". ->? seemed like a good choice.
   */
let (->?) = (opt, getNew) =>
  switch (opt) {
  | Some(_) as v => v
  | None => getNew()
  };

/* Finds the path of the Windows 10 SDK directory
   This is very hacky, but it's the way Visual Studio does it
   so I'm confident this would work across OS installs. */
let findWindows10SDKHelper = (basePath, ()) => {
  // Find the registry key of the SDK installation folder
  let lines =
    exec(
      Printf.sprintf(
        "reg query \"%s\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\" /v \"InstallationFolder\"",
        basePath,
      ),
    );

  // If a key was found, there are 4 lines:
  // (blank)
  // [Path to registry key]
  // [Key]    [Type]    [Value]
  // (blank)
  if (List.length(lines) == 4) {
    // We care about the line with the value
    let relevantLine = List.nth(lines, 2);
    let elements = Str.split(Str.regexp_string("    "), relevantLine);
    let path = List.nth(elements, 2) |> String.trim;

    // Find the subdirectories that satisfy the constraints
    let lines =
      exec(Printf.sprintf("dir \"%sinclude\\\" /b /ad-h /on", path));

    // If any of these versions lead to SDK headers, we found the SDK!
    let validate = line => {
      let version = String.trim(line);
      let sdkPath =
        Printf.sprintf("%sinclude\\%s\\um\\winsdkver.h", path, version);
      Sys.file_exists(sdkPath);
    };
    switch (lines |> List.filter(validate)) {
    | [] => None
    | [version, ..._] => Some(Windows10(path, String.trim(version)))
    };
  } else {
    None;
  };
};

let findWindows81SDKHelper = (basePath, ()) => {
  // Find the registry key of the SDK installation folder
  let lines =
    exec(
      Printf.sprintf(
        "reg query \"%s\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\" /v \"InstallationFolder\"",
        basePath,
      ),
    );

  if (List.length(lines) == 4) {
    let relevantLine = List.nth(lines, 2);
    let elements = Str.split(Str.regexp_string("    "), relevantLine);
    let path = List.nth(elements, 2) |> String.trim;
    Some(Windows81(path));
  } else {
    None;
  };
};

let findWindowsSDK = () => {
  // Visual Studio tries all these paths
  findWindows10SDKHelper("HKLM\\SOFTWARE\\WOW6432Node", ())
  ->? findWindows10SDKHelper("HKCU\\SOFTWARE\\WOW6432Node")
  ->? findWindows10SDKHelper("HKLM\\SOFTWARE")
  ->? findWindows10SDKHelper("HKCU\\SOFTWARE")
  ->? findWindows81SDKHelper("HKLM\\SOFTWARE\\WOW6432Node")
  ->? findWindows81SDKHelper("HKCU\\SOFTWARE\\WOW6432Node")
  ->? findWindows81SDKHelper("HKLM\\SOFTWARE")
  ->? findWindows81SDKHelper("HKCU\\SOFTWARE");
};

let patch = (input, output, manifest) =>
  if (Revery.Environment.isWindows) {
    switch (findWindowsSDK()) {
    | Some(sdk) =>
      let mtExePath = {
        switch (sdk) {
        | Windows10(path, version) =>
          Printf.sprintf("\"%sbin\\%s\\x64\\mt.exe\"", path, version)
        | Windows81(path) => Printf.sprintf("\"%s\\bin\\x64\\mt.exe\"", path)
        };
      };
      let cpCommand = Printf.sprintf("cp \"%s\" \"%s\"", input, output);
      let chmodCommand = Printf.sprintf("chmod +w %s", output);
      let mtExeCommand =
        Printf.sprintf(
          "%s -manifest %s -outputresource:%s",
          mtExePath,
          manifest,
          output,
        );
      exec(cpCommand) |> ignore;
      exec(chmodCommand) |> ignore;
      exec(mtExeCommand) |> ignore;
    | None => ()
    };
  } else {
    let cpCommand = Printf.sprintf("cp \"%s\" \"%s\"", input, output);
    exec(cpCommand) |> ignore;
  };

let () = {
  open Arg;
  let inputPath = ref("");
  let outputPath = ref("");
  let manifestPath = ref("");

  let args = [
    ("-input", Set_string(inputPath), "The path of the input executable"),
    ("-output", Set_string(outputPath), "The path of the output executable"),
    ("-manifest", Set_string(manifestPath), "The path of the manifest"),
  ];

  let unwrapArg = ref' => {
    switch (ref'^) {
    | "" => raise(Invalid_argument("Missing required parameter"))
    | v => v
    };
  };

  parse(
    args,
    _ => (),
    "Patches a Windows PE file with a manifest using mt.exe",
  );

  let inputPath = unwrapArg(inputPath);
  let outputPath = unwrapArg(outputPath);
  let manifestPath = unwrapArg(manifestPath);

  patch(inputPath, outputPath, manifestPath);
};
